"""
Utility functions for working with segmentation masks.

This module provides helper functions to inspect, convert, and analyze
mask files generated by the Cell Segmentation Tool.
"""

import numpy as np
from pathlib import Path
import argparse


def inspect_mask(mask_path):
    """
    Print detailed information about a mask file.
    
    Args:
        mask_path: Path to the .npy mask file
    """
    masks = np.load(mask_path)
    
    print(f"\n{'='*60}")
    print(f"Mask File: {Path(mask_path).name}")
    print(f"{'='*60}")
    print(f"Shape: {masks.shape}")
    print(f"Data type: {masks.dtype}")
    print(f"Memory size: {masks.nbytes / 1024:.2f} KB")
    print(f"\nMask Statistics:")
    print(f"  Total masks: {len(np.unique(masks)) - 1}")  # Exclude background
    print(f"  Mask IDs: {np.unique(masks)[1:]}")  # Skip 0
    print(f"  Background pixels: {np.sum(masks == 0)}")
    print(f"  Masked pixels: {np.sum(masks > 0)}")
    print(f"  Coverage: {np.sum(masks > 0) / masks.size * 100:.2f}%")
    
    # Individual mask statistics
    print(f"\nIndividual Mask Areas (pixels):")
    for mask_id in np.unique(masks)[1:]:
        area = np.sum(masks == mask_id)
        print(f"  Mask {mask_id}: {area} pixels")
    
    print(f"{'='*60}\n")


def export_to_png(mask_path, output_path=None):
    """
    Export masks as a colored PNG image for visualization.
    
    Args:
        mask_path: Path to the .npy mask file
        output_path: Optional output path for PNG (default: same name as mask with .png)
    """
    try:
        from PIL import Image
        import cv2
    except ImportError:
        print("Error: PIL (Pillow) is required for PNG export")
        return
    
    # Load masks
    masks = np.load(mask_path)
    
    # Create colored image
    colored = np.zeros((*masks.shape, 3), dtype=np.uint8)
    
    for mask_id in np.unique(masks)[1:]:  # Skip background
        # Generate consistent color using HSV
        hue = (mask_id * 137) % 180  # Same as in the main tool
        color = cv2.cvtColor(np.uint8([[[hue, 255, 255]]]), cv2.COLOR_HSV2RGB)[0, 0]
        colored[masks == mask_id] = color
    
    # Determine output path
    if output_path is None:
        output_path = str(Path(mask_path).with_suffix('.png'))
    
    # Save as PNG
    Image.fromarray(colored).save(output_path)
    print(f"Exported masks to: {output_path}")


def export_to_binary(mask_path, mask_id, output_path=None):
    """
    Export a single mask as a binary image (0 or 255).
    
    Args:
        mask_path: Path to the .npy mask file
        mask_id: ID of the mask to export
        output_path: Optional output path for binary mask
    """
    try:
        from PIL import Image
    except ImportError:
        print("Error: PIL (Pillow) is required for binary export")
        return
    
    # Load masks
    masks = np.load(mask_path)
    
    # Extract single mask
    binary = (masks == mask_id).astype(np.uint8) * 255
    
    # Determine output path
    if output_path is None:
        base = Path(mask_path).stem
        output_path = str(Path(mask_path).parent / f"{base}_mask{mask_id}.png")
    
    # Save as PNG
    Image.fromarray(binary).save(output_path)
    print(f"Exported mask {mask_id} to: {output_path}")


def merge_masks(mask_paths, output_path):
    """
    Merge multiple mask files into a single file.
    
    Mask IDs are automatically offset to avoid conflicts.
    Overlapping masks from later files override earlier ones.
    
    Args:
        mask_paths: List of paths to .npy mask files
        output_path: Path for the merged output file
    """
    if len(mask_paths) < 2:
        print("Error: Need at least 2 mask files to merge")
        return
    
    # Load first mask
    merged = np.load(mask_paths[0]).astype(np.int32)
    current_max_id = merged.max()
    
    print(f"Merging {len(mask_paths)} mask files...")
    print(f"  Base: {Path(mask_paths[0]).name} ({current_max_id} masks)")
    
    # Merge remaining masks
    for mask_path in mask_paths[1:]:
        masks = np.load(mask_path).astype(np.int32)
        
        # Offset IDs to avoid conflicts
        masks_offset = np.where(masks > 0, masks + current_max_id, 0)
        
        # Merge (later masks override earlier ones in overlapping regions)
        merged = np.where(masks_offset > 0, masks_offset, merged)
        
        num_masks = len(np.unique(masks)[1:])
        current_max_id = merged.max()
        
        print(f"  Added: {Path(mask_path).name} ({num_masks} masks)")
    
    # Save merged result
    np.save(output_path, merged)
    total_masks = len(np.unique(merged)) - 1
    print(f"\nMerged {total_masks} total masks to: {output_path}")


def split_masks(mask_path, output_dir=None):
    """
    Split a mask file into individual binary masks (one file per cell).
    
    Args:
        mask_path: Path to the .npy mask file
        output_dir: Optional output directory (default: same as mask file)
    """
    # Load masks
    masks = np.load(mask_path)
    
    # Determine output directory
    if output_dir is None:
        output_dir = Path(mask_path).parent
    else:
        output_dir = Path(output_dir)
        output_dir.mkdir(exist_ok=True)
    
    base_name = Path(mask_path).stem
    
    # Extract each mask
    mask_ids = np.unique(masks)[1:]  # Skip background
    
    print(f"Splitting {len(mask_ids)} masks from {Path(mask_path).name}...")
    
    for mask_id in mask_ids:
        binary = (masks == mask_id).astype(np.uint8)
        output_path = output_dir / f"{base_name}_id{mask_id}.npy"
        np.save(output_path, binary)
        print(f"  Saved mask {mask_id} to {output_path.name}")
    
    print(f"\nAll masks saved to: {output_dir}")


def calculate_statistics(mask_path):
    """
    Calculate detailed statistics for all masks in a file.
    
    Returns area, centroid, and bounding box for each mask.
    
    Args:
        mask_path: Path to the .npy mask file
    """
    from scipy import ndimage
    
    masks = np.load(mask_path)
    mask_ids = np.unique(masks)[1:]  # Skip background
    
    print(f"\n{'='*80}")
    print(f"Mask Statistics: {Path(mask_path).name}")
    print(f"{'='*80}")
    print(f"{'ID':<5} {'Area (px)':<12} {'Centroid (x, y)':<20} {'Bounding Box (x, y, w, h)':<30}")
    print(f"{'-'*80}")
    
    stats = []
    
    for mask_id in mask_ids:
        # Extract binary mask
        binary = (masks == mask_id)
        
        # Area
        area = np.sum(binary)
        
        # Centroid
        centroid = ndimage.center_of_mass(binary)
        centroid_xy = (int(centroid[1]), int(centroid[0]))  # Convert to x,y
        
        # Bounding box
        coords = np.argwhere(binary)
        y_min, x_min = coords.min(axis=0)
        y_max, x_max = coords.max(axis=0)
        bbox = (int(x_min), int(y_min), int(x_max - x_min + 1), int(y_max - y_min + 1))
        
        # Store stats
        stat = {
            'id': mask_id,
            'area': area,
            'centroid': centroid_xy,
            'bbox': bbox
        }
        stats.append(stat)
        
        # Print
        print(f"{mask_id:<5} {area:<12} {str(centroid_xy):<20} {str(bbox):<30}")
    
    print(f"{'='*80}\n")
    
    return stats


def main():
    """Command-line interface for mask utilities."""
    parser = argparse.ArgumentParser(
        description="Utility functions for segmentation masks",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Inspect a mask file
  python mask_utils.py inspect my_cells_seg.npy
  
  # Export as colored PNG
  python mask_utils.py export my_cells_seg.npy
  
  # Calculate statistics
  python mask_utils.py stats my_cells_seg.npy
  
  # Merge multiple mask files
  python mask_utils.py merge output.npy file1_seg.npy file2_seg.npy file3_seg.npy
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Command to run')
    
    # Inspect command
    inspect_parser = subparsers.add_parser('inspect', help='Inspect a mask file')
    inspect_parser.add_argument('mask_file', help='Path to .npy mask file')
    
    # Export command
    export_parser = subparsers.add_parser('export', help='Export masks as colored PNG')
    export_parser.add_argument('mask_file', help='Path to .npy mask file')
    export_parser.add_argument('-o', '--output', help='Output PNG path')
    
    # Stats command
    stats_parser = subparsers.add_parser('stats', help='Calculate mask statistics')
    stats_parser.add_argument('mask_file', help='Path to .npy mask file')
    
    # Merge command
    merge_parser = subparsers.add_parser('merge', help='Merge multiple mask files')
    merge_parser.add_argument('output', help='Output path for merged masks')
    merge_parser.add_argument('mask_files', nargs='+', help='Mask files to merge')
    
    # Split command
    split_parser = subparsers.add_parser('split', help='Split masks into individual files')
    split_parser.add_argument('mask_file', help='Path to .npy mask file')
    split_parser.add_argument('-o', '--output_dir', help='Output directory')
    
    args = parser.parse_args()
    
    # Execute command
    if args.command == 'inspect':
        inspect_mask(args.mask_file)
    elif args.command == 'export':
        export_to_png(args.mask_file, args.output)
    elif args.command == 'stats':
        calculate_statistics(args.mask_file)
    elif args.command == 'merge':
        merge_masks(args.mask_files, args.output)
    elif args.command == 'split':
        split_masks(args.mask_file, args.output_dir)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()


